"""
    set_generator.py

    Summary:
        Contains a class for generating a convex safe set around a point

    Author: Trym Tengesdal
"""
from typing import Optional, Tuple

import numpy as np
from scipy.spatial import HalfspaceIntersection


class SetGenerator(object):
    """
    Set generation class, which generates convex sets around a center point P, The sets that are generated
    will not cross or overlap with linesegments of the constraints. The resulting sets are on the form:

        S = {x | Ax <= b}

    Where A is a matrix and b is a vector

    """

    def __init__(self, P1: list, P2: list):
        """
        The Set generation class is initialized with static line segments defined by the two end points P1 and P2

        Arguments
        ---------
        P1: array_like (N x 2)
            List of start point for linesegments

        P2: array_like (N x 2)
            List of end point for linesegments
        """
        self.P1 = np.array(P1)
        self.P2 = np.array(P2)

    def close_points(self, P: np.ndarray, Pr: np.ndarray = np.eye(2), Pd1: Optional[np.ndarray] = None, Pd2: Optional[np.ndarray] = None) -> np.ndarray:
        """
        Finds the closest point Pc to P on each linesegment (the points that you are closest to colliding with).
        The problem is an optimization problem on the form:

            min_t  ||Pc - P||^2

            s.t. Pc = (1 - t)*P1 + t*P2
                 0 <= t <= 1

        Luckily the problem has a nice closed form solution:

            t = - clip( ((P1 - P)^T(P2 - P1)) / ((P2 - P1)^T(P2 - P1)), 0, 1)

        Arguments
        ---------
        P:
            The point from which to calculate Pc

        Keyword Arguments
        -----------------
        Pr:
            Positive definite projection matrix, used to choose expansion direction
            ex: R(psi) diag([s_1 s_2]) R(psi)^T will expandin along heding psi
        Pd1:
            Dynamic line segment start point
        Pd2:
            Dynamic line segment end point

        """
        if (Pd1 is not None) and (Pd2 is not None):
            P1 = np.concatenate((self.P1, Pd1), axis=0)
            P2 = np.concatenate((self.P2, Pd2), axis=0)

        else:
            P1 = self.P1
            P2 = self.P2

        s1 = np.sum((P1 - P) @ Pr * (P2 - P1), axis=1)
        s2 = np.sum((P2 - P1) @ Pr * (P2 - P1), axis=1)

        t = -np.true_divide(s1, s2, where=(s2 != 0)) * (s2 != 0)
        t = np.clip(t, 0, 1).reshape((-1, 1))
        Pc = (1 - t) * P1 + t * P2

        return Pc

    def __call__(
        self,
        P: np.ndarray,
        Pr: np.ndarray = np.eye(2),
        Pd1: Optional[np.ndarray] = None,
        Pd2: Optional[np.ndarray] = None,
        reduce: str = "continuous",
        epsilon: float = 1e-6,
    ) -> Tuple[np.ndarray, np.ndarray]:
        """
        Find and return the set S = {x | Ax <= b}, generated about P, The sets are generated by erecting the normal
        ray to the point Pc closest to P on each linesegment P1, P2, this  is done in the following way:

            A = (Pc - P)^T
            b = (Pc - P)^T Pc


        Arguments
        ---------
        P:
            Point around which to generate set

        Keyword Arguments
        -----------------
        Pr:
            Positive definite projection matrix, used to choose expansion direction
            ex: R(psi) diag([s_1 s_2]) R(psi)^T will expandin along heding psi
        Pd:
            Additional dynamic constraints
        reduce: sting
            Type of constraint reduction options are none|continuous|minimal, none gives the lagest number of
            constraints, continuous recuces significantly, and minimal reduces slighly more than continuous
        epsilon: float
            Small value between 0 and 1, tolerance during reduction (Ax <= (1 - epsilon)*b)

        Returns
        -------
        tuple: (A, b)

        """

        # Compute closest points
        Pc = self.close_points(P, Pr, Pd1, Pd2)

        # Sort points by how close they are (euclidean distance)
        closest = np.argsort(Pr[0, 0] * (Pc[:, 0] - P[0]) ** 2 + (Pr[0, 1] + Pr[1, 0]) * (Pc[:, 0] - P[0]) * (Pc[:, 1] - P[1]) + Pr[0, 0] * (Pc[:, 1] - P[1]) ** 2)

        if reduce == "none":
            N = np.sqrt(np.sum(((Pc - P) @ Pr)[closest] * ((Pc - P) @ Pr)[closest], axis=1)).reshape(-1, 1)  # Normalizing factor
            N[N == 0] = 1  # Avoid dividing by 0 (alternativly add a small positive epsilon when computing N above)
            A = (((Pc - P) @ Pr)[closest]) / N
            b = np.sum(A * Pc[closest], axis=1)

            return A, b

        elif reduce == "continuous":
            N = np.sqrt(np.sum(((Pc - P) @ Pr)[closest] * ((Pc - P) @ Pr)[closest], axis=1)).reshape(-1, 1)  # Normalizing factor
            N[N == 0] = 1  # Avoid dividing by 0 (alternativly add a small positive epsilon when computing N above)
            A = (((Pc - P) @ Pr)[closest]) / N
            b = np.sum(A * Pc[closest], axis=1)

            # Compute halfspace intersection
            Ab = np.concatenate((A, -b.reshape((-1, 1))), axis=1)
            hs = HalfspaceIntersection(Ab, P)
            hs.close()

            return A[hs.dual_vertices], b[hs.dual_vertices]

        elif reduce == "minimal":
            mask: list = []
            tmp = np.ones(len(closest), dtype=bool)

            if (Pd1 is not None) and (Pd2 is not None):
                P1 = np.concatenate((self.P1, Pd1), axis=0)
                P2 = np.concatenate((self.P2, Pd2), axis=0)

            else:
                P1 = self.P1
                P2 = self.P2

            while len(closest[tmp[closest]]) > len(mask):
                # Append closest bound that have not yet been cut off
                mask.append(closest[tmp[closest]][len(mask)])

                # Remove potential bounds where both endponts are cut off by new bound
                A = (Pc - P)[mask[-1]]
                b = np.sum(A * Pc[mask[-1]], axis=0)

                tmp = tmp & (((A @ P1.T).T <= (1 - epsilon) * b) | ((A @ P2.T).T <= (1 - epsilon) * b))
                tmp[mask] = True

            N = np.sqrt(np.sum((Pc - P)[mask] * (Pc - P)[mask], axis=1)).reshape(-1, 1)  # Normalizing factor
            N[N == 0] = 1  # Avoid dividing by 0 (alternativly add a small positive epsilon when computing N above)
            A = ((Pc - P)[mask]) / N
            b = np.sum(A * Pc[mask], axis=1)

            # Compute halfspace intersection
            Ab = np.concatenate((A, -b.reshape((-1, 1))), axis=1)
            hs = HalfspaceIntersection(Ab, P)
            hs.close()
            A = A[hs.dual_vertices]
            b = b[hs.dual_vertices]

            return A, b
        else:
            raise ValueError("Unknown reduction method")
